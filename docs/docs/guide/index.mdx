---
title: HM - 鸿蒙-组件基础
---

# 鸿蒙-组件基础

## 开发环境

### 1. 起步-鸿蒙简介

介绍：

- HarmonyOS 是新一代的智能终端操作系统，为不同设备的智能化、互联与协同提供了统一的语言。带来简洁，流畅，连续，安全可靠的全场景交互体验。

历程：

| 时间     | 事件                                                                                    |
| -------- | --------------------------------------------------------------------------------------- |
| 2019     | HarmonyOS 1.0，华为在东莞举行华为开发者大会，正式发布操作系统鸿蒙 OS，主要用于物联网    |
| 2020     | HarmonyOS 2.0，基于开源项目 OpenHarmony 开发的面向多种全场景智能设备的商用版本          |
| 2021     | HarmonyOS 3.0，先后优化游戏流畅度、地图三维体验、系统安全，另外系统的稳定性也得到了增强 |
| 2023.2   | HarmonyOS 3.1，系统纯净能力进一步提升，对后台弹窗、 隐藏应用、后台跳转等情况            |
| 2023.7   | 华为 Mate 50 系列手机获推 HarmonyOS 4.0                                                 |
| **2024** | **HarmonyOS Next 即将发布，将不在兼容安卓应用**                                         |

和我们有什么关系？

- 环境弱行业卷，怎么办？
- 纯鸿蒙应用开发潮，你跟不跟？
- 前端技术迁移鸿蒙开发易上手，你学不学？

### 2. 起步-DevEco Studio

    <img src="./images/01.png" width="600" />

安装 DevEco Studio 编辑器

1. 下载：https://developer.harmonyos.com/cn/develop/deveco-studio#download
   - Windows(64-bit)
   - Mac(X86)
   - Mac(ARM)
2. 安装：DevEco Studio → 一路 Next
3. 运行：
   - 基础安装：Node.js >= 16.9.1 + Install ohpm 鸿蒙包管理器
     <img src="./images/02.png" width="600" />
   - SDK 安装
     <img src="./images/03.png" width="600" />
   - 安装完毕
     <img src="./images/04.png" width="600" />

### 3. 起步-HelloWorld

创建一个空项目:

1. Create Project

   <img src="./images/05.png" width="600" />

2. 选择项目模板

   <img src="./images/06.png" width="600" />

3. 填写项目信息

   <img src="./images/07.png" width="600" />

4. Finish
   <img src="./images/08.png" width="600" />

### 4. 起步-调试预览

调试预览方法：

- Previewer 预览模式
- Local Emulator 本地模拟器
- Remote Emulator 远程模拟器
- Remote Device 远程真机
- Local Device 本地真机

::: tip 推荐使用

- Previewer 预览 和 Local Emulator 本地模拟器；
- 尤其推荐使用 `遥遥领先` 真机调试；

:::

1）Previewer 预览

> 场景：静态页面（没有组件间数据通信、不涉及到网络请求）  
> 条件：有 @Entry 或 @Preview 装饰器页面

- 预览和审查元素

  <img src="./images/09.png" width="600" />

- 多设备预览

  <img src="./images/10.png" width="600" />

2）Local Emulator 本地模拟器

> 场景：动态页面（几乎全场景，一些无法模拟的硬件功能）

- 新建模拟器

  <img src="./images/11.png" width="600" />
  一路 Next ...

- 启动模拟器

  <img src="./images/12.png" width="600" />

- 运行项目看效果

  <img src="./images/13.png" width="600" />

- 更改后每次需要（打包 → 卸载 → 安装 → 预览），有没有热更新或者刷新这种预览方式？

  <img src="./images/14.png" width="600" />
  调试静态页面可以，一旦有了数据变化也需要重启，体验一般~ （学习需要耐心，期待 Next 做的更好~）

::: tip 其他方式

- Remote Emulator 远程模拟器
- Remote Device 远程真机
- Local Device 本地真机

条件：需要注册华为账号, 点这 https://developer.harmonyos.com/ 然后点击登录页面，去注册吧~

:::

### 5. 起步-工程结构

> 我们在哪里写代码？

    State 模型

    <img src="./images/16.png" width="100%" />

了解App结构关系，等后面我们项目阶段来讲一些工程配置文件作用，现在你要知道：
- entry 是一个 Module 应用包
- entryability 是一个 UIAbility 包含用户界面的应用组件
- pages 是页面
- components 可以是组件

    <img src="./images/17.png" width="600" />


## 组件基础

### 1. 组件-什么是ArkTS

ArkTS是HarmonyOS优选的主力应用开发语言。ArkTS围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展，继承了TS的所有特性，是TS的超集。

    <img src="./images/18.png" width="400" />

扩展能力如下：

1. 基本语法
    - 定义声明式UI、自定义组件、动态扩展UI元素；
    - 提供ArkUI系统组件，提供组件事件、方法、属性；
    - 共同构成 UI 开发主体
2. 状态管理
    - 组件状态、组件数据共享、应用数据共享、设备共享；
3. 渲染控制
    - 条件渲染、循环渲染、数据懒加载；

::: tip 声明式UI？

问题？通过一段 `HTML` 标签展示出对应的页面方便，还是使用 `document.createElement('tag')`创建标签构建页面方便？
- 显然是 HTML , 其实 HTML 本身就是声明式的，通过描述的方式去声明 UI 界面。
- 一些前端框架也是声明式UI，如 `Vue` 使用的 `tempalte` 模板，如 `React` 使用的 `JSX`。
- 在例如现在的 `Jetpack Compose` `SwiftUI` `Flutter` 等APP开发技术也是声明式。

:::

### 2. 基础-组件结构

    <img src="./images/15.png" width="600" />

ArkTS通过装饰器 `@Component` 和 `@Entry` 装饰 `struct` 关键字声明的数据结构，构成一个自定义组件。
自定义组件中提供了一个 `build` 函数，开发者需在该函数内以链式调用的方式进行基本的 UI 描述，UI 描述的方法请参考 UI 描述规范。


1）页面组件

```typescript
@Entry
@Component
struct Index {
  // 工程默认显示 `Index` 页面组件
  // build 是声明UI的位置
  build() {
    Text('页面组件')
  }
}
```


2）自定义组件

```typescript

// 定义 `Footer` 组件
@Component
struct Footer {
  build() {
    Text('自定义组件')
  }
}

@Entry
@Component
struct Index {
  build() {
    // 使用 `Footer` 组件
    Footer()
  }
}
```

为了更好维护，自定义组件通常会新建一个文件 `Footer.ets`，通过模块化语法导出导入(默认|按需)使用。

- File: `components/Footer.ets`

```typescript
@Component
export default struct Footer {
  build() {
    Text('自定义组件')
  }
}
```

- File: `Index.ets`

```typescript
import Footer from './components/Footer.ets'

@Entry
@Component
struct Index {
  build() {
    // 使用 `Footer` 组件
    Footer()
  }
}
```

::: tip

- `@Entry @Component` 是页面组件，将来需要页面跳转就需要再定义一个页面。
- `@Component` 自定义组件，一个页面组件下可以有多个自定义组件。
- `build(){}` 只能有一个根元素

:::


### 3. 基础-系统组件(ArkUI)

常用系统组件 `Text` `Column` `Row` `Button` `TextInput`  [更多组件](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-components-summary-0000001478181369-V3)


- Text 文本组件
- Column 列组件，纵向排列，Flex布局主轴是Y
- Row 行组件，横向向排列，Flex布局主轴是X
- Button 按钮组件
- InputText 输入框组件

实现一个简易登录界面：

<img src="./images/19.png" width="240"  />

```typescript
@Entry
@Component
struct Index {

  build() {
    Column(){
      Row(){
        Text('手机号')
        TextInput()
      }
      Row(){
        Text('验证码')
        TextInput()
      }
      Row(){
        Button('重置').backgroundColor('#ccc')
        Button('登录')
      }
    }
  }
}
```

::: tip

- ArkUI 组件都是 Flex 模式，由行和列组成。

:::


### 4. 基础-组件状态

> 如何使用 `@State` 定义一个状态变量？

1）组件变量，不具备驱动UI更新能力。

```typescript
@Entry
@Component
struct Index {
  count = 100

  build() {
    Text(this.count.toString())
      .onClick(() => this.count++)
  }
}
```

2）状态变量，指驱动UI更新的数据，加上 `@State` 装饰器即可，注意：加上**类型**和**初始值**。
```typescript
@Entry
@Component
struct Index {

  @State
  count: number = 100

  build() {
    Text(this.count.toString())
      .onClick(() => this.count++)
  }
}
```


::: tip

- 状态变量不可设置的类型有：`any` `undefined` `null` `与复杂类型的联合类型`
- 绑定事件在系统组件后链式使用 `onXxxxx` 进行绑定即可
- 使用 `@ohos.promptAction` 可以使用亲提示 `promptAction.showToast({ message: 'Tip' })`

:::


📕📕📕 练习案例→实现登录表单数据收集、重置、模拟提交。

<img src="./images/19.png" width="240"  />

```typescript
import promptAction from '@ohos.promptAction'
@Entry
@Component
struct Index {

  @State
  mobile: string = ''
  @State
  code: string = ''

  build() {
    Column(){
      Row(){
        Text('手机号')
        TextInput({ text: this.mobile }).onChange((value)=>this.mobile = value)
      }
      Row(){
        Text('验证码')
        TextInput({ text: this.code }).onChange((value)=>this.code = value)
      }
      Row(){
        Button('重置')
          .backgroundColor('#ccc')
          .onClick(()=>{
            this.mobile = ''
            this.code = ''
          })
        Button('登录')
          .onClick(()=>{
            if (this.mobile && this.code) {
              promptAction.showToast({ message: `${this.mobile} 登录成功` })
            } else {
              promptAction.showToast({ message: `请输入手机号或验证码` })
            }
          })
      }
    }
  }
}
```

## 样式处理

### 1. 样式-布局容器

### 2. 样式-语法(链式&枚举)

### 3. 样式-@Styles 复用

### 4. 样式-@Extends 复用

## 组件状态

### 1. 状态-简单状态

### 2. 状态-复杂状态

## 界面渲染

### 1. 渲染-条件渲染

### 2. 渲染-循环渲染

## 今日案例
