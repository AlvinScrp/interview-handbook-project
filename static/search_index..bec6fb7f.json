[{"id":0,"title":"HM - 鸿蒙-路由&原生能力","routePath":"/interview-handbook-project/guide/app","lang":"","toc":[],"domain":"","content":"#","frontmatter":{"title":"HM - 鸿蒙-路由&原生能力"},"version":""},{"id":1,"title":"HM - 鸿蒙-组件基础","routePath":"/interview-handbook-project/guide/","lang":"","toc":[{"text":"开发环境","id":"开发环境","depth":2,"charIndex":3},{"text":"1. 起步-鸿蒙简介","id":"1-起步-鸿蒙简介","depth":3,"charIndex":11},{"text":"2. 起步-DevEco Studio","id":"2-起步-deveco-studio","depth":3,"charIndex":510},{"text":"3. 起步-HelloWorld","id":"3-起步-helloworld","depth":3,"charIndex":795},{"text":"4. 起步-效果预览","id":"4-起步-效果预览","depth":3,"charIndex":881},{"text":"5. 起步-工程结构","id":"5-起步-工程结构","depth":3,"charIndex":1580},{"text":"组件基础","id":"组件基础","depth":2,"charIndex":1761},{"text":"1. 组件-什么是ArkTS","id":"1-组件-什么是arkts","depth":3,"charIndex":1769},{"text":"2. 基础-组件结构","id":"2-基础-组件结构","depth":3,"charIndex":2292},{"text":"3. 基础-系统组件(ArkUI)","id":"3-基础-系统组件arkui","depth":3,"charIndex":3083},{"text":"4. 基础-组件状态","id":"4-基础-组件状态","depth":3,"charIndex":3596},{"text":"样式处理","id":"样式处理","depth":2,"charIndex":5045},{"text":"1. 样式-语法(链式&枚举)","id":"1-样式-语法链式枚举","depth":3,"charIndex":5053},{"text":"2. 样式-单位vp和适配","id":"2-样式-单位vp和适配","depth":3,"charIndex":5685},{"text":"2. 样式-@Styles 复用","id":"2-样式-styles-复用","depth":3,"charIndex":8885},{"text":"3. 样式-@Extends 复用","id":"3-样式-extends-复用","depth":3,"charIndex":11402},{"text":"4. 样式-多态","id":"4-样式-多态","depth":3,"charIndex":12345},{"text":"组件状态","id":"组件状态","depth":2,"charIndex":13986},{"text":"1. 状态-class语法","id":"1-状态-class语法","depth":3,"charIndex":13994},{"text":"2. 状态-复杂状态","id":"2-状态-复杂状态","depth":3,"charIndex":15049},{"text":"界面渲染","id":"界面渲染","depth":2,"charIndex":16989},{"text":"1. 渲染-条件渲染","id":"1-渲染-条件渲染","depth":3,"charIndex":16997},{"text":"2. 渲染-循环渲染","id":"2-渲染-循环渲染","depth":3,"charIndex":18264},{"text":"今日案例","id":"今日案例","depth":2,"charIndex":19438},{"text":"1. 底部输入区域","id":"1-底部输入区域","depth":3,"charIndex":19446},{"text":"2. 静态回复列表","id":"2-静态回复列表","depth":3,"charIndex":21834},{"text":"3. 实现渲染","id":"3-实现渲染","depth":3,"charIndex":23100},{"text":"4. 实现点赞","id":"4-实现点赞","depth":3,"charIndex":27263},{"text":"6. 进行回复","id":"6-进行回复","depth":3,"charIndex":27968}],"domain":"","content":"#\n\n\n开发环境#\n\n\n1. 起步-鸿蒙简介#\n\n介绍：\n\n * HarmonyOS 是新一代的智能终端操作系统，为不同设备的智能化、互联与协同提供了统一的语言。带来简洁，流畅，连续，安全可靠的全场景交互体验。\n\n历程：\n\n时间       事件\n2019     HarmonyOS 1.0，华为在东莞举行华为开发者大会，正式发布操作系统鸿蒙 OS，主要用于物联网\n2020     HarmonyOS 2.0，基于开源项目 OpenHarmony 开发的面向多种全场景智能设备的商用版本\n2021     HarmonyOS 3.0，先后优化游戏流畅度、地图三维体验、系统安全，另外系统的稳定性也得到了增强\n2023.2   HarmonyOS 3.1，系统纯净能力进一步提升，对后台弹窗、 隐藏应用、后台跳转等情况\n2023.7   华为 Mate 50 系列手机获推 HarmonyOS 4.0\n2024     HarmonyOS Next 即将发布，将不在兼容安卓应用\n\n和我们有什么关系？\n\n * 环境弱行业卷，怎么办？\n * 纯鸿蒙应用开发潮，你跟不跟？\n * 前端技术迁移鸿蒙开发易上手，你学不学？\n\n\n2. 起步-DevEco Studio#\n\n安装 DevEco Studio 编辑器\n\n 1. 下载：https://developer.harmonyos.com/cn/develop/deveco-studio#download\n    * Windows(64-bit)\n    * Mac(X86)\n    * Mac(ARM)\n 2. 安装：DevEco Studio → 一路 Next\n 3. 运行：\n    * 基础安装：Node.js >= 16.9.1 + Install ohpm 鸿蒙包管理器\n    * SDK 安装\n    * 安装完毕\n\n\n3. 起步-HelloWorld#\n\n创建一个空项目:\n\n 1. Create Project\n\n 2. 选择项目模板\n\n 3. 填写项目信息\n\n 4. Finish\n\n\n4. 起步-效果预览#\n\n效果预览方法：\n\n * Previewer 预览模式\n * Local Emulator 本地模拟器\n * Remote Emulator 远程模拟器\n * Remote Device 远程真机\n * Local Device 本地真机\n\n推荐使用\n * Previewer 预览 和 Local Emulator 本地模拟器；\n * 尤其推荐使用 遥遥领先 真机调试；\n\n1）Previewer 预览\n\n> 场景：静态页面（没有组件间数据通信、不涉及到网络请求）\n> \n> 条件：有 @Entry 或 @Preview 装饰器页面\n\n * 预览和审查元素\n\n * 多设备预览\n\n2）Local Emulator 本地模拟器\n\n> 场景：动态页面（几乎全场景，一些无法模拟的硬件功能）\n\n * 新建模拟器\n   \n   一路 Next ...\n\n * 启动模拟器\n\n * 运行项目看效果\n\n * 更改后每次需要（打包 → 卸载 → 安装 → 预览），有没有热更新或者刷新这种预览方式？\n   \n   调试静态页面可以，一旦有了数据变化也需要重启，体验一般~ （学习需要耐心，期待 Next 做的更好~）\n\n其他方式\n * Remote Emulator 远程模拟器\n * Remote Device 远程真机\n * Local Device 本地真机\n\n条件：\n\n * 需要注册华为账号, 点这 https://developer.harmonyos.com/ 然后点击登录页面，去注册吧~\n * 登录之后，需要自动生成签名信息，这个我们后面讲真机调试再给大家演示。\n\n\n5. 起步-工程结构#\n\n> 我们在哪里写代码？\n\nState 模型\n\n了解App结构关系，等后面我们项目阶段来讲一些工程配置文件作用，现在你要知道：\n\n * entry 是一个 Module 应用包\n\n * entryability 是一个 UIAbility 包含用户界面的应用组件\n\n * pages 是页面\n\n * components 可以是组件\n\n\n组件基础#\n\n\n1. 组件-什么是ArkTS#\n\nArkTS是HarmonyOS优选的主力应用开发语言。ArkTS围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展，继承了TS的所有特性，是\nTS的超集。\n\n扩展能力如下：\n\n 1. 基本语法\n    * 定义声明式UI、自定义组件、动态扩展UI元素；\n    * 提供ArkUI系统组件，提供组件事件、方法、属性；\n    * 共同构成 UI 开发主体\n 2. 状态管理\n    * 组件状态、组件数据共享、应用数据共享、设备共享；\n 3. 渲染控制\n    * 条件渲染、循环渲染、数据懒加载；\n\n声明式UI？\n\n问题？通过一段 HTML 标签展示出对应的页面方便，还是使用 document.createElement('tag')创建标签构建页面方便？\n\n * 显然是 HTML , 其实 HTML 本身就是声明式的，通过描述的方式去声明 UI 界面。\n * 一些前端框架也是声明式UI，如 Vue 使用的 tempalte 模板，如 React 使用的 JSX。\n * 在例如现在的 Jetpack Compose SwiftUI Flutter 等APP开发技术也是声明式。\n\n\n2. 基础-组件结构#\n\nArkTS通过装饰器 @Component 和 @Entry 装饰 struct 关键字声明的数据结构，构成一个自定义组件。 自定义组件中提供了一个 build\n函数，开发者需在该函数内以链式调用的方式进行基本的 UI 描述，UI 描述的方法请参考 UI 描述规范。\n\n1）页面组件\n\n@Entry\n@Component\nstruct Index {\n  // 工程默认显示 `Index` 页面组件\n  // build 是声明UI的位置\n  build() {\n    Text('页面组件')\n  }\n}\n\n\n2）自定义组件\n\n\n// 定义 `Footer` 组件\n@Component\nstruct Footer {\n  build() {\n    Text('自定义组件')\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    // 使用 `Footer` 组件\n    Footer()\n  }\n}\n\n\n为了更好维护，自定义组件通常会新建一个文件 Footer.ets，通过模块化语法导出导入(默认|按需)使用。\n\n@Component\nexport default struct Footer {\n  build() {\n    Text('自定义组件')\n  }\n}\n\n\n\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    // 使用 `Footer` 组件\n    Footer()\n  }\n}\n\n\nTIP\n * @Entry @Component 是页面组件，将来需要页面跳转就需要再定义一个页面。\n * @Component 自定义组件，一个页面组件下可以有多个自定义组件。\n * build(){} 只能有一个根元素\n\n\n3. 基础-系统组件(ArkUI)#\n\n常用系统组件 Text Column Row Button TextInput 更多组件\n\n * Text 文本组件\n * Column 列组件，纵向排列，Flex布局主轴是Y\n * Row 行组件，横向向排列，Flex布局主轴是X\n * Button 按钮组件\n * InputText 输入框组件\n\n实现一个简易登录界面：\n\n@Entry\n@Component\nstruct Index {\n\n  build() {\n    Column(){\n      Row(){\n        Text('手机号')\n        TextInput()\n      }\n      Row(){\n        Text('验证码')\n        TextInput()\n      }\n      Row(){\n        Button('重置').backgroundColor('#ccc')\n        Button('登录')\n      }\n    }\n  }\n}\n\n\nTIP\n * ArkUI 组件一般都是 Flex 模式，大部分布局可以由行和列组成。\n\n\n4. 基础-组件状态#\n\n> 如何使用 @State 定义一个状态变量？\n\n1）组件变量，不具备驱动UI更新能力。\n\n@Entry\n@Component\nstruct Index {\n  count = 100\n\n  build() {\n    Text(this.count.toString())\n      .onClick(() => this.count++)\n  }\n}\n\n\n2）状态变量，指驱动UI更新的数据，加上 @State 装饰器即可，注意：加上类型和初始值。\n\n@Entry\n@Component\nstruct Index {\n\n  @State\n  count: number = 100\n\n  build() {\n    Text(this.count.toString())\n      .onClick(() => this.count++)\n  }\n}\n\n\nTIP\n * 加上类型和初始值\n * 状态变量不可设置的类型有：any undefined null 与复杂类型的联合类型\n\n其他：\n\n * 绑定事件在系统组件后链式使用 onXxxxx 进行绑定即可\n * 使用 @ohos.promptAction 可以进行轻提示 promptAction.showToast({ message: 'Tip' })\n\n📕📕📕 练习案例→实现登录表单数据收集、重置、模拟提交。\n\n\n@Entry\n@Component\nstruct Index {\n\n  @State\n  mobile: string = ''\n  @State\n  code: string = ''\n\n  build() {\n    Column(){\n      Row(){\n        Text('手机号')\n        TextInput({ text: this.mobile })\n          .onChange((value)=>this.mobile = value)\n      }\n      Row(){\n        Text('验证码')\n        TextInput({ text: this.code })\n          .onChange((value)=>this.code = value)\n      }\n      Row(){\n        Button('重置')\n          .backgroundColor('#ccc')\n          .onClick(()=>{\n            this.mobile = ''\n            this.code = ''\n          })\n        Button('登录')\n          .onClick(()=>{\n            if (this.mobile && this.code) {\n              promptAction.showToast({ message: `${this.mobile} 登录成功` })\n            } else {\n              promptAction.showToast({ message: `请输入手机号或验证码` })\n            }\n          })\n      }\n    }\n  }\n}\n\n\n\n样式处理#\n\n\n1. 样式-语法(链式&枚举)#\n\n> ArkTS以声明方式组合和扩展组件来描述应用程序的UI；\n> \n> 同时还提供了基本的属性、事件和子组件配置方法，帮助开发者实现应用交互逻辑。\n\n1）样式属性\n\n * 属性方法以 . 链式调用的方式配置系统组件的样式和其他属性，建议每个属性方法单独写一行。\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    Text('演示')\n      .backgroundColor('red')\n      .fontSize(50)\n      .width('100%')\n      .height(100)\n  }\n}\n\n\n2）枚举值\n\n * 对于系统组件，ArkUI还为其属性预定义了一些枚举类型。文档链接\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    Text('演示')\n      .fontSize(50)\n      .width('100%')\n      .height(100)\n      .backgroundColor(Color.Blue)\n      .textAlign(TextAlign.Center)\n      .fontColor(Color.White)\n  }\n}\n\n\nTIP\n * 样式相关属性通过链式函数的方式进行设置\n * 如果类型是枚举的，通过枚举传入对应的值\n\n\n2. 样式-单位vp和适配#\n\n> 知道 vp 单位，以及适配思想\n\n1） vp 是什么？virtual pixel\n\n * 屏幕密度相关像素，根据屏幕像素密度转换为屏幕物理像素，当数值不带单位时，默认单位 vp；在实际宽度为1440物理像素的屏幕上，1vp 约等于\n   3px（物理像素）\n\n * 上图的意思是，使用这个单位在不同屏幕物理分辨率的实际尺寸一致(A设备1英寸，B设备1英寸)。\n\n2）之前 vw 、rem 和 rpx 相对于屏幕宽度的单位，可以实现等比例适配，vp 可以吗？\n\n\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    Text('演示')\n      .width('100%')\n      .backgroundColor('red')\n      .onAreaChange((oldArea, newArea) => {\n        promptAction.showToast({\n          // 1. onAreaChange改变尺寸后会触发\n          // 2. newArea为现在元素尺寸\n          message: newArea.width.toString()\n        })\n      })\n  }\n}\n\n\n我们发现：不同的设备屏幕的宽度 vp 是不一致的，那怎么适配呢？\n\n3）根据官方的文档，结合自己的理解，采用：伸缩布局，网格系统，栅格系统进行布局适配。\n\n伸缩 layoutWeight(flex: number) 占剩余空间多少份，可以理解成CSS的 flex: 1\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    Row(){\n      Text('left')\n        .layoutWeight(1)\n        .backgroundColor('red')\n      Text('right')\n        .layoutWeight(2)\n        .backgroundColor('green')\n    }\n    .width('100%')\n  }\n}\n\n\n等比例，设置元素宽高比 aspectRatio(ratio: number)\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    Text('left')\n      .width('50%')\n        // 宽高比例\n      .aspectRatio(1)\n      .backgroundColor('red')\n  }\n}\n\n\nTIP\n * vp 是鸿蒙默认单位，和屏幕像素有关，最终表现视觉大小在任何设备一致\n * 鸿蒙一般以伸缩layoutWeight、网格、栅格进行布局适配，如要等比例缩放可以设置高宽比 aspectRatio\n\n📕📕📕 练习案例→实现知乎评论回复-评论区域\n\n设计稿一般是1080px：(这里没有设计稿，提供了一些尺寸)\n\n * Nav\n   * 左侧返回按钮24vp高宽背景颜色#f5f5f5，图标12vp尺寸颜色#848484\n   * 标题18vp\n * commen\n   * 头像尺寸32vp高宽，右侧间距10vp\n   * 标题15vp，颜色默认\n   * 内容16vp，颜色#565656\n   * 底部12vp，颜色#c3c4c5\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    Column() {\n      // nav\n      Row() {\n        Row() {\n          Image($r('app.media.left'))\n            .width(12)\n            .aspectRatio(1)\n            .fillColor('#848484')\n        }\n        .width(24)\n        .height(24)\n        .borderRadius(12)\n        .backgroundColor('#f5f5f5')\n        .justifyContent(FlexAlign.Center)\n        .margin({ left: 13 })\n\n        Text('评论回复')\n          .padding({ right: 50 })\n          .textAlign(TextAlign.Center)\n          .fontSize(18)\n          .layoutWeight(1)\n      }\n      .height(50)\n      // comment\n      Row() {\n        Image($r('app.media.avatar'))\n          .width(32)\n          .aspectRatio(1)\n          .borderRadius(16)\n        Column() {\n          Text('周杰伦')\n            .fontSize(15)\n            .fontWeight(FontWeight.Bold)\n            .margin({ bottom: 5 })\n          Text('大理石能雕刻出肌肉和皮肤的质感，那个年代的工匠好牛啊')\n            .margin({ bottom: 5 })\n            .fontColor('#565656')\n            .lineHeight(20)\n          Row() {\n            Text('10-21•IP 属地辽宁')\n              .layoutWeight(1)\n              .fontSize(14)\n              .fontColor('#c3c4c5')\n            Row() {\n              Image($r('app.media.heart'))\n                .width(14)\n                .aspectRatio(1)\n                .fillColor('#c3c4c5')\n                .margin({ right: 4 })\n              Text('100')\n                .fontSize(14)\n                .fontColor('#c3c4c5')\n            }\n          }\n        }\n        .layoutWeight(1)\n        .padding({ left: 10 })\n        .alignItems(HorizontalAlign.Start)\n      }\n      .width('100%')\n      .padding({ left: 15, right: 15, bottom: 15 })\n      .alignItems(VerticalAlign.Top)\n    }\n  }\n}\n\n\n\n2. 样式-@Styles 复用#\n\n> 在开发过程中会出现大量代码在进行重复样式设置，@Styles 可以帮我们进行样式复用\n\n * 当前@Styles仅支持 通用属性 和 通用事件。\n * 支持 全局 定义和 组件内 定义，同时存在组件内覆盖全局生效。\n\n// 全局\n@Styles \nfunction functionName() { ... }\n\n@Entry\n@Component\nsturt Index{\n  // 组件内\n  @Styles \n  functionName() { ... }\n\n  build() {\n    Text('Text')\n      .functionName()\n  }\n}\n\n\n需求：文字和按钮相同背景，点击+1\n\n1）全局\n\n@Styles function sameStyle() {\n  .backgroundColor(Color.Green)\n  .onClick(() => {\n    this.count++\n  })\n}\n\n@Entry\n@Component\nstruct Index {\n  @State\n  count: number = 10\n\n  build() {\n    Column() {\n      Text(this.count.toString())\n        .width(100)\n        .height(50)\n        .margin({ bottom: 10 })\n        .textAlign(TextAlign.Center)\n        .sameStyle()\n\n      Button('+1')\n        .sameStyle()\n    }\n    .height('100%')\n    .width('100%')\n    .justifyContent(FlexAlign.Center)\n  }\n}\n\n\n2）组件内\n\n@Entry\n@Component\nstruct Index {\n  @State\n  count: number = 10\n\n  // 不需要 `function` 关键字，覆盖全局\n  @Styles\n  sameStyle (){\n    .backgroundColor(Color.Pink)\n    .onClick(() => {\n      this.count += 10\n    })\n  }\n\n  build() {\n    Column() {\n      Text(this.count.toString())\n        .width(100)\n        .height(50)\n        .margin({ bottom: 10 })\n        .textAlign(TextAlign.Center)\n        .sameStyle()\n\n      Button('+1')\n        .sameStyle()\n    }\n    .height('100%')\n    .width('100%')\n    .justifyContent(FlexAlign.Center)\n  }\n}\n\n\n📕📕📕 练习案例-登录表单-样式优化\n\n\n@Entry\n@Component\nstruct Index {\n\n  @State\n  mobile: string = ''\n  @State\n  code: string = ''\n\n\n  @Styles\n  inputStyle () {\n    .border({ width: 1, color: Color.Gray })\n    .layoutWeight(1)\n    .margin({ left: 10, bottom: 10, top: 10 })\n    .backgroundColor(Color.White)\n  }\n\n  build() {\n    Column(){\n      Row(){\n        Text('手机号')\n        TextInput({ text: this.mobile })\n          .inputStyle()\n          .onChange((value)=>this.mobile = value)\n      }\n      Row(){\n        Text('验证码')\n        TextInput({ text: this.code })\n          .inputStyle()\n          .onChange((value)=>this.code = value)\n      }\n      Row({ space: 15 }){\n        Button('重置')\n          .backgroundColor('#ccc')\n          .onClick(()=>{\n            this.mobile = ''\n            this.code = ''\n          })\n        Button('登录')\n          .onClick(()=>{\n            if (this.mobile && this.code) {\n              promptAction.showToast({ message: `${this.mobile} 登录成功` })\n            } else {\n              promptAction.showToast({ message: `请输入手机号或验证码` })\n            }\n          })\n      }\n    }\n    .padding({ left: 15, right: 15 })\n  }\n}\n\n\n\n3. 样式-@Extends 复用#\n\n> @Extend 用于扩展原生组件样式，通过传参提供更灵活的样式复用\n\n * 使用 @Extend 装饰器修饰的函数只能是 全局\n * 函数可以进行 传参，如果参数是状态变量，状态更新后会刷新UI\n * 且参数可以是一个函数，实现复用事件且可处理不同逻辑\n\n// 全局  原生组件                     参数\n//  ↓     ↓                          ↓ \n@Extend(Text) function functionName(w: number) { \n  .width(w)\n}\n\n\n需求：把 Text 改成按钮样式，且绑定 click 事件执行不同逻辑\n\n\n\n@Extend(Text) function myClick(color: string, cb: () => void) {\n  .backgroundColor(color)\n  .width(100)\n  .height(50)\n  .textAlign(TextAlign.Center)\n  .borderRadius(25)\n  .onClick(() => cb())\n}\n\n@Entry\n@Component\nstruct Other {\n  @State\n  color: string = '#ccc'\n\n  build() {\n    Column({ space: 20 }) {\n      Text('Text1')\n        .myClick(this.color, () => {\n          this.color = '#069'\n        })\n      Text('Text2')\n        .myClick('green', () => {\n          promptAction.showToast({ message: '做其他事~' })\n        })\n    }\n    .width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center)\n  }\n}\n\n\n\n4. 样式-多态#\n\n> stateStyles可以依据组件的内部状态的不同，快速设置不同样式。\n\nstateStyles 是属性方法，可以根据UI内部状态来设置样式，类似于 css 伪类，但语法不同。ArkUI 提供以下四种状态：\n\n * focused：获焦态。\n\n * normal：正常态。\n\n * pressed：按压态。\n\n * disabled：不可用态。\n\n\n\n// 胶囊按钮\n@Extend(Text)\nfunction capsule(){\n  .height(40)\n  .borderRadius(20)\n  .backgroundColor(Color.Gray)\n  .padding({ left: 15, right: 15 })\n  .margin({ bottom: 15 })\n}\n\n@Entry\n@Component\nstruct Index {\n  @State\n  disabled: boolean = false\n  @State\n  focused: boolean = false\n\n  build() {\n    Column() {\n\n      // Button TextInput 默认开启获取焦点，页面中默认第一个这样的元素获取焦点\n      // Button 比较多限制，一个是默认开启获取焦点能看，二是禁用状态下样式无法修改\n      // Button('Button').focusable(false)\n\n      Text('toggle disabled：' + this.disabled)\n        .capsule()\n        .onClick(()=>{\n          this.disabled = !this.disabled\n        })\n      Text('toggle focused：' + this.focused)\n        .capsule()\n        .onClick(()=>{\n          this.focused = !this.focused\n        })\n      Text('clickMe')\n        .capsule()\n        .enabled(!this.disabled)\n        .focusable(this.focused)\n        .onClick(() => {\n          promptAction.showToast({ message: 'click' })\n        })\n        .fontColor('#fff')\n        .stateStyles({\n          normal: {\n            .backgroundColor(Color.Blue)\n          },\n          focused: {\n            .backgroundColor(Color.Red)\n          },\n          disabled: {\n            .backgroundColor(Color.Black)\n          },\n          pressed: {\n            .backgroundColor(Color.Orange)\n          }\n        })\n    }\n  }\n}\n\n\nTIP\n * 使用比较多的应该是 normal pressed 结合下的按压效果\n * enabled(true|false) 开启|禁用 focusable(true|false) 开启获取焦点能力|关闭\n\n注意：\n\n * 页面初始化的时候，默认第一个能获取焦点的元素，会自动获取焦点\n\n\n组件状态#\n\n\n1. 状态-class语法#\n\n> 在鸿蒙开发中关于对象状态范式采用 class 方式，后续组件传值遇到深层对象嵌套需要利用 class\n\n1）class 创建对象和 class 类型\n\nclass Person {\n  age: number;\n  name: string;\n\n  constructor(name: string, age: number) {\n    this.name = name\n    this.age = age\n  }\n}\n\n// 当类型使用和构当造函数使用\nconst p: Person = new Person('jack', 18)\n// 当类型使用这种使用后续居多，我们使用字面量对象居多，可以省略 constructor\nconst p1: Person = {\n  name: 'tom',\n  age: 20\n}\n\n\n2）implements 实现 interface 接口\n\ninterface IPerson {\n  name: string,\n  age: number,\n  say: () => void\n}\n\n// 实现 IPerson 接口，需要符合接口约定\nclass Person implements IPerson{\n  age: number;\n  name: string;\n\n  constructor(name: string, age: number) {\n    this.name = name\n    this.age = age\n  }\n\n  say () {\n    promptAction.showToast({ message: this.name })\n  }\n}\n\n\n3）extends 继承\n\nclass HmPerson extends Person {\n  github: string = 'https://github.com/zhousg'\n\n  coding () {\n    promptAction.showToast({ message: this.name + ': coding' })\n  }\n}\n\n\nTIP\n * 定义类 class 类名 { 属性 + 构造器 + 方法 }，类可以创建对象，也可以当类型使用。\n\n扩展：\n\n * class 可以实现 implements 接口，需要受到接口约束\n * class 可以继承 extends 另外一个class的属性和方法\n\n\n2. 状态-复杂状态#\n\n> 当装饰的数据类型为class或者Object时，可以观察到自身的赋值的变化，和其属性赋值的变化，即Object.keys(observedObject)返回\n> 的所有属性。\n\n1）对象类型状态\n\n// 对象模型\nclass User {\n  nickname: string\n  age: number\n}\n\n@Entry\n@Component\nstruct Index {\n\n  @State\n  user: User = { nickname: 'jack', age: 18 }\n\n  build() {\n    Column({ space: 20 }){\n      Text(this.user.nickname)\n      Text(this.user.age.toString())\n      Button('age++')\n        .onClick(() => {\n          this.user.age ++\n        })\n    }\n    .width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center)\n  }\n}\n\n\n2）嵌套对象类型状态\n\n// 对象模型\nclass User {\n  nickname: string\n  age: number\n}\n\nclass UserData {\n  code: number\n  message: string\n  // 嵌套对象\n  data: User\n}\n\n@Entry\n@Component\nstruct Index {\n  @State\n  res: UserData = {\n    code: 10000,\n    message: '获取用户信息成功',\n    // 嵌套对象\n    data: { nickname: 'jack', age: 18 }\n  }\n\n  build() {\n    Column({ space: 20 }) {\n      Text(this.res.data.nickname)\n      Text(this.res.data.age.toString())\n      Button('age++')\n        .onClick(() => {\n          // ❌ this.res.data.age ++\n          const user = this.res.data\n          // 替换属性，触发UI更新\n          this.res.data = { ...user, age: user.age + 1 }\n        })\n    }\n    .width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center)\n  }\n}\n\n\n3）对象数组类型状态\n\n// 对象模型\nclass User {\n  nickname: string\n  age: number\n}\n\n@Entry\n@Component\nstruct Index {\n  @State\n  list: User[] = [\n    { nickname: 'jack', age: 18 },\n    { nickname: 'tom', age: 16 }\n  ]\n  build() {\n    Column({ space: 20 }) {\n      Text(JSON.stringify(this.list[0]))\n      Text(JSON.stringify(this.list[1]))\n      Button('age++')\n        .onClick(() => {\n          // ❌ this.list[1].age ++\n          const user = this.list[1]\n          this.list[1] = { ...user, age: user.age + 1 }\n        })\n    }\n    .width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center)\n  }\n}\n\n\nTIP\n * 使用 class 来约束对象类型，和嵌套对象和对象数组。\n * 嵌套对象和对象数组，采用赋值的方式进行更新，可以更新UI。\n\n\n界面渲染#\n\n\n1. 渲染-条件渲染#\n\n> 条件渲染可根据应用的不同状态，使用if、else和else if渲染对应状态下的UI内容。\n\n * 条件渲染，是根据状态数据进行判断展示不同UI\n * 添加渲染，是会销毁和创建组件，组件状态将不会保留\n\n1）使用 if else 实现 loading 效果\n\n@Entry\n@Component\nstruct Index {\n\n  @State\n  loading: boolean = false\n\n  build() {\n    Column({ space: 20 }){\n      if (this.loading) {\n        LoadingProgress()\n          .width(100)\n          .height(100)\n      } else  {\n        Text('后台数据')\n        Text('后台数据')\n        Text('后台数据')\n      }\n      Button('更新数据')\n        .onClick(() => {\n          this.loading = true\n          setTimeout(() => {\n            this.loading = false\n          }, 2000)\n        })\n    }\n    .width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center)\n  }\n}\n\n\n2）添加渲染会销毁和重新创建组件，组件状态将不会保留。\n\n@Component\nstruct CounterComp {\n  @State\n  count: number = 0\n\n  build() {\n    Text(this.count.toString())\n      .onClick(() => {\n        this.count ++\n      })\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n\n  @State\n  show: boolean = true\n\n  build() {\n    Column({ space: 20 }){\n      if (this.show) {\n        // 累计的 count 切换时候不会保留\n        CounterComp()\n      }\n      Button('toggle')\n        .onClick(() => {\n          this.show = !this.show\n        })\n    }\n    .width('100%')\n    .height('100%')\n    .justifyContent(FlexAlign.Center)\n  }\n}\n\n\n\n2. 渲染-循环渲染#\n\n> ForEach 接口基于数组类型数据来进行循环渲染，需要与容器组件配合使用。\n\n语法：\n\nForEach(\n  // 数据源\n  arr: Array,\n  // 组件生成函数\n  itemGenerator: (item: Array, index?: number) => void,\n  // 键值生成函数\n  keyGenerator?: (item: Array, index?: number): string => string\n)\n\n\n应用：\n\nclass User {\n  id: string\n  name: string\n  age: number\n}\n\n\n@Entry\n@Component\nstruct Index {\n  @State\n  userList: User[] = []\n\n  build() {\n    Scroll() {\n      Column({ space: 20 }) {\n        // 循环渲染\n        ForEach(\n          // 1. 数据源\n          this.userList,\n          // 2. 组件生成函数\n          (item: User) => {\n            // 内容\n            Text(`${item.name} 今年 ${item.age} 岁`)\n          },\n          // 3. 键值生成函数\n          item => item.id\n        )\n        Button('加载更多')\n          .onClick(() => {\n            const arr: User[] = []\n            for (let index = 0; index < 10; index++) {\n              arr.push({ id: Math.random().toString(), name: 'jack', age: Math.ceil(Math.random() * 100) })\n            }\n            this.userList.push(...arr)\n          })\n      }\n    }\n    .width('100%')\n  }\n}\n\n\nTIP\n\n关于 keyGenerator 键生成函数的一些建议：\n\n * 不能缺省\n * 避免最终生成的键包含 index\n * 对象数组，建议使用对象中 id 唯一标识\n * 基本数据数字，建议转换成具有 id 唯一标识的对象，再使用\n\n\n今日案例#\n\n\n1. 底部输入区域#\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    Stack() {\n      Scroll() {\n        Column() {\n          NavComp()\n          CommentComp()\n          // TODO space\n          // TODO reply\n        }\n      }\n      .padding({ bottom: 50 })\n\n      Row() {\n        TextInput({ placeholder: '回复~' })\n          .placeholderColor('#c3c4c5')\n          .layoutWeight(1)\n        Text('发布')\n          .fontSize(14)\n          .fontColor('#09f')\n          .margin({ left: 15 })\n      }\n      .width('100%')\n      .height(50)\n      .padding({ left: 15, right: 15 })\n      .position({ y: '100%' })\n      .translate({ y: -50 })\n      .backgroundColor('#fff')\n      .border({ width: { top: 0.5 }, color: '#e4e4e4' })\n    }\n  }\n}\n\n\n@Component\nstruct NavComp {\n  build() {\n    // nav\n    Row() {\n      Row() {\n        Image($r('app.media.left'))\n          .width(12)\n          .height(12)\n          .fillColor('#848484')\n      }\n      .width(24)\n      .height(24)\n      .borderRadius(12)\n      .backgroundColor('#f5f5f5')\n      .justifyContent(FlexAlign.Center)\n      .margin({ left: 13 })\n\n      Text('评论回复')\n        .padding({ right: 50 })\n        .textAlign(TextAlign.Center)\n        .fontSize(18)\n        .layoutWeight(1)\n    }\n    .height(50)\n  }\n}\n\n@Component\nstruct CommentComp {\n  build() {\n    // comment\n    Row() {\n      Image('https://picx.zhimg.com/1754b6bd9_xl.jpg?source=c885d018')\n        .width(32)\n        .height(32)\n        .borderRadius(16)\n      Column() {\n        Text('欧洲足球锦标赛')\n          .fontSize(15)\n          .fontWeight(FontWeight.Bold)\n          .margin({ bottom: 5 })\n        Text('14-0！欧洲杯超级惨案+刷爆纪录！姆巴佩帽子戏法，法国7连胜，怎么评价这场比赛？')\n          .margin({ bottom: 5 })\n          .fontColor('#565656')\n          .lineHeight(20)\n        Row() {\n          Text('10-21•IP 属地辽宁')\n            .layoutWeight(1)\n            .fontSize(14)\n            .fontColor('#c3c4c5')\n          Row() {\n            Image($r('app.media.heart'))\n              .width(14)\n              .height(14)\n              .fillColor('#c3c4c5')\n              .margin({ right: 4 })\n            Text('100')\n              .fontSize(14)\n              .fontColor('#c3c4c5')\n          }\n        }\n      }\n      .layoutWeight(1)\n      .padding({ left: 10 })\n      .alignItems(HorizontalAlign.Start)\n    }\n    .width('100%')\n    .padding({ left: 15, right: 15, bottom: 15 })\n    .alignItems(VerticalAlign.Top)\n  }\n}\n\n\n\n2. 静态回复列表#\n\n\n// space\nDivider()\n  .strokeWidth(8)\n  .color('#f5f5f5')\n// reply\nColumn() {\n  Text('回复 7')\n    .width('100%')\n    .margin({ bottom: 15 })\n    .fontWeight(500)\n  ForEach([1, 2, 3, 4, 5, 6, 7], () => {\n    Row() {\n      Image($r('app.media.avatar'))\n        .width(32)\n        .height(32)\n        .borderRadius(16)\n      Column() {\n        Text('周杰伦')\n          .fontSize(15)\n          .fontWeight(FontWeight.Bold)\n          .margin({ bottom: 5 })\n        Text('大理石能雕刻出肌肉和皮肤的质感，那个年代的工匠好牛啊')\n          .margin({ bottom: 5 })\n          .fontColor('#565656')\n          .lineHeight(20)\n        Row() {\n          Text('10-21•IP 属地辽宁')\n            .layoutWeight(1)\n            .fontSize(14)\n            .fontColor('#c3c4c5')\n          Row() {\n            Image($r('app.media.heart'))\n              .width(14)\n              .height(14)\n              .fillColor('#c3c4c5')\n              .margin({ right: 4 })\n            Text('100')\n              .fontSize(14)\n              .fontColor('#c3c4c5')\n          }\n        }\n      }\n      .layoutWeight(1)\n      .padding({ left: 10 })\n      .alignItems(HorizontalAlign.Start)\n    }\n    .width('100%')\n    .padding({ bottom: 15 })\n    .alignItems(VerticalAlign.Top)\n  })\n}\n.padding({ left: 15, right: 15, top: 15 })\n\n\n\n3. 实现渲染#\n\nexport class ReplyItem {\n  id: number\n  avatar: string\n  author: string\n  content: string\n  time: string\n  area: string\n  likeNum: number\n  likeFlag?: boolean\n}\n\nexport const replyList: ReplyItem[] = [\n  {\n    id: 1,\n    avatar: 'https://picx.zhimg.com/027729d02bdf060e24973c3726fea9da_l.jpg?source=06d4cd63',\n    author: '偏执狂-妄想家',\n    content: '更何况还分到一个摩洛哥[惊喜]',\n    time: '11-30',\n    area: '海南',\n    likeNum: 34\n  },\n  {\n    id: 2,\n    avatar: 'https://pic1.zhimg.com/v2-5a3f5190369ae59c12bee33abfe0c5cc_xl.jpg?source=32738c0c',\n    author: 'William',\n    content: '当年希腊可是把1：0发挥到极致了',\n    time: '11-29',\n    area: '北京',\n    likeNum: 58\n  },\n  {\n    id: 3,\n    avatar: 'https://picx.zhimg.com/v2-e6f4605c16e4378572a96dad7eaaf2b0_l.jpg?source=06d4cd63',\n    author: 'Andy Garcia',\n    content: '欧洲杯其实16队球队打正赛已经差不多，24队打正赛意味着正赛阶段在小组赛一样有弱队。',\n    time: '11-28',\n    area: '上海',\n    likeNum: 10\n  },\n  {\n    id: 4,\n    avatar: 'https://picx.zhimg.com/v2-53e7cf84228e26f419d924c2bf8d5d70_l.jpg?source=06d4cd63',\n    author: '正宗好鱼头',\n    content: '确实眼红啊，亚洲就没这种球队，让中国队刷',\n    time: '11-27',\n    area: '香港',\n    likeNum: 139\n  },\n  {\n    id: 5,\n    avatar: 'https://pic1.zhimg.com/v2-eeddfaae049df2a407ff37540894c8ce_l.jpg?source=06d4cd63',\n    author: '柱子哥',\n    content: '我是支持扩大的，亚洲杯欧洲杯扩到32队，世界杯扩到64队才是好的，世界上有超过200支队伍，欧洲区55支队伍，亚洲区47支队伍，即使如此也就六成出现率',\n    time: '11-27',\n    area: '旧金山',\n    likeNum: 29\n  },\n  {\n    id: 6,\n    avatar: 'https://picx.zhimg.com/v2-fab3da929232ae911e92bf8137d11f3a_l.jpg?source=06d4cd63',\n    author: '飞轩逸',\n    content: '禁止欧洲杯扩军之前，应该先禁止世界杯扩军，或者至少把亚洲名额一半给欧洲。',\n    time: '11-26',\n    area: '里约',\n    likeNum: 100\n  }\n]\n\n\n\n\n@Entry\n@Component\nstruct Index {\n\n  @State\n  replyList: ReplyItem[] = replyList\n\n  build() {\n    Stack() {\n      Scroll() {\n        Column() {\n          NavComp()\n          CommentComp()\n          // space\n          Divider()\n            .strokeWidth(8)\n            .color('#f5f5f5')\n          // reply\n          Column() {\n            Text('回复 7')\n              .width('100%')\n              .margin({ bottom: 15 })\n              .fontWeight(500)\n            ForEach(this.replyList, (item: ReplyItem) => {\n              Row() {\n                Image(item.avatar)\n                  .width(32)\n                  .height(32)\n                  .borderRadius(16)\n                Column() {\n                  Text(item.author)\n                    .fontSize(15)\n                    .fontWeight(FontWeight.Bold)\n                    .margin({ bottom: 5 })\n                  Text(item.content)\n                    .margin({ bottom: 5 })\n                    .fontColor('#565656')\n                    .lineHeight(20)\n                  Row() {\n                    Text(`${item.time}•IP 属地${item.area}`)\n                      .layoutWeight(1)\n                      .fontSize(14)\n                      .fontColor('#c3c4c5')\n                    Row() {\n                      Image($r('app.media.heart'))\n                        .width(14)\n                        .height(14)\n                        .fillColor('#c3c4c5')\n                        .margin({ right: 4 })\n                      Text(item.likeNum.toString())\n                        .fontSize(14)\n                        .fontColor('#c3c4c5')\n                    }\n                  }\n                }\n                .layoutWeight(1)\n                .padding({ left: 10 })\n                .alignItems(HorizontalAlign.Start)\n              }\n              .width('100%')\n              .padding({ bottom: 15 })\n              .alignItems(VerticalAlign.Top)\n            })\n          }\n          .padding({ left: 15, right: 15, top: 15 })\n        }\n      }\n      .padding({ bottom: 50 })\n\n      Row() {\n        TextInput({ placeholder: '回复~' })\n          .placeholderColor('#c3c4c5')\n          .layoutWeight(1)\n        Text('发布')\n          .fontSize(14)\n          .fontColor('#09f')\n          .margin({ left: 15 })\n      }\n      .width('100%')\n      .height(50)\n      .padding({ left: 15, right: 15 })\n      .position({ y: '100%' })\n      .translate({ y: -50 })\n      .backgroundColor('#fff')\n      .border({ width: { top: 0.5 }, color: '#e4e4e4' })\n    }\n  }\n}\n\n\n\n4. 实现点赞#\n\nonLike(item: ReplyItem) {\n  const reply = { ...item }\n  if (reply.likeFlag) {\n    reply.likeNum--\n    reply.likeFlag = false\n    promptAction.showToast({ message: '取消点赞' })\n  } else {\n    reply.likeNum++\n    reply.likeFlag = true\n    promptAction.showToast({ message: '点赞成功' })\n  }\n  const index = this.replyList.findIndex(rep => rep.id === reply.id)\n  this.replyList.splice(index, 1, reply)\n}\n\n\nRow() {\n  Image($r('app.media.heart'))\n    .width(14)\n    .height(14)\n    .fillColor(item.likeFlag ? '#ff6600' : '#c3c4c5')\n    .margin({ right: 4 })\n  Text(item.likeNum.toString())\n    .fontSize(14)\n    .fontColor(item.likeFlag ? '#ff6600' : '#c3c4c5')\n}\n.onClick(() => {\n  this.onLike(item)\n})\n\n\n\n6. 进行回复#\n\nexport class ReplyItem {\n  id: number\n+  avatar: string | Resource\n  author: string\n  content: string\n  time: string\n  area: string\n  likeNum: number\n  likeFlag?: boolean\n}\n\n\nonReply () {\n  const reply: ReplyItem = {\n    id: this.replyList[this.replyList.length-1].id + 1,\n    content: this.content,\n    author: 'Zhousg',\n    avatar: $r('app.media.avatar'),\n    time: '12-01',\n    likeNum: 0,\n    area: '北京'\n  }\n  this.replyList.unshift(reply)\n  this.content = ''\n  promptAction.showToast({ message: '回复成功' })\n}\n\n\nRow() {\n  TextInput({ placeholder: '回复~', text: this.content })\n    .placeholderColor('#c3c4c5')\n    .layoutWeight(1)\n    .onChange((value) => {\n      this.content = value\n    })\n  Text('发布')\n    .fontSize(14)\n    .fontColor('#09f')\n    .margin({ left: 15 })\n    .onClick(()=>{\n      this.onReply()\n    })\n}\n","frontmatter":{"title":"HM - 鸿蒙-组件基础"},"version":""},{"id":2,"title":"HM - 鸿蒙-状态管理","routePath":"/interview-handbook-project/guide/state","lang":"","toc":[],"domain":"","content":"#","frontmatter":{"title":"HM - 鸿蒙-状态管理"},"version":""},{"id":4,"title":"面试宝典APP","routePath":"/interview-handbook-project/project/","lang":"","toc":[],"domain":"","content":"#","frontmatter":{},"version":""}]