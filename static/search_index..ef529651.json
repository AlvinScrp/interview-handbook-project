[{"id":0,"title":"HM - 鸿蒙-路由&原生能力","routePath":"/interview-handbook-project/guide/app","lang":"","toc":[],"domain":"","content":"#","frontmatter":{"title":"HM - 鸿蒙-路由&原生能力"},"version":""},{"id":1,"title":"HM - 鸿蒙-组件基础","routePath":"/interview-handbook-project/guide/","lang":"","toc":[{"text":"开发环境","id":"开发环境","depth":2,"charIndex":3},{"text":"1. 起步-鸿蒙简介","id":"1-起步-鸿蒙简介","depth":3,"charIndex":11},{"text":"2. 起步-DevEco Studio","id":"2-起步-deveco-studio","depth":3,"charIndex":510},{"text":"3. 起步-HelloWorld","id":"3-起步-helloworld","depth":3,"charIndex":795},{"text":"4. 起步-调试预览","id":"4-起步-调试预览","depth":3,"charIndex":881},{"text":"5. 起步-工程结构","id":"5-起步-工程结构","depth":3,"charIndex":1537},{"text":"组件基础","id":"组件基础","depth":2,"charIndex":1718},{"text":"1. 组件-什么是ArkTS","id":"1-组件-什么是arkts","depth":3,"charIndex":1726},{"text":"2. 基础-组件结构","id":"2-基础-组件结构","depth":3,"charIndex":2249},{"text":"3. 基础-系统组件(ArkUI)","id":"3-基础-系统组件arkui","depth":3,"charIndex":3092},{"text":"4. 基础-组件状态","id":"4-基础-组件状态","depth":3,"charIndex":3596},{"text":"样式处理","id":"样式处理","depth":2,"charIndex":5005},{"text":"1. 样式-布局容器","id":"1-样式-布局容器","depth":3,"charIndex":5013},{"text":"2. 样式-语法(链式&枚举)","id":"2-样式-语法链式枚举","depth":3,"charIndex":5027},{"text":"3. 样式-@Styles 复用","id":"3-样式-styles-复用","depth":3,"charIndex":5046},{"text":"4. 样式-@Extends 复用","id":"4-样式-extends-复用","depth":3,"charIndex":5066},{"text":"组件状态","id":"组件状态","depth":2,"charIndex":5087},{"text":"1. 状态-简单状态","id":"1-状态-简单状态","depth":3,"charIndex":5095},{"text":"2. 状态-复杂状态","id":"2-状态-复杂状态","depth":3,"charIndex":5109},{"text":"界面渲染","id":"界面渲染","depth":2,"charIndex":5123},{"text":"1. 渲染-条件渲染","id":"1-渲染-条件渲染","depth":3,"charIndex":5131},{"text":"2. 渲染-循环渲染","id":"2-渲染-循环渲染","depth":3,"charIndex":5145},{"text":"今日案例","id":"今日案例","depth":2,"charIndex":-1}],"domain":"","content":"#\n\n\n开发环境#\n\n\n1. 起步-鸿蒙简介#\n\n介绍：\n\n * HarmonyOS 是新一代的智能终端操作系统，为不同设备的智能化、互联与协同提供了统一的语言。带来简洁，流畅，连续，安全可靠的全场景交互体验。\n\n历程：\n\n时间       事件\n2019     HarmonyOS 1.0，华为在东莞举行华为开发者大会，正式发布操作系统鸿蒙 OS，主要用于物联网\n2020     HarmonyOS 2.0，基于开源项目 OpenHarmony 开发的面向多种全场景智能设备的商用版本\n2021     HarmonyOS 3.0，先后优化游戏流畅度、地图三维体验、系统安全，另外系统的稳定性也得到了增强\n2023.2   HarmonyOS 3.1，系统纯净能力进一步提升，对后台弹窗、 隐藏应用、后台跳转等情况\n2023.7   华为 Mate 50 系列手机获推 HarmonyOS 4.0\n2024     HarmonyOS Next 即将发布，将不在兼容安卓应用\n\n和我们有什么关系？\n\n * 环境弱行业卷，怎么办？\n * 纯鸿蒙应用开发潮，你跟不跟？\n * 前端技术迁移鸿蒙开发易上手，你学不学？\n\n\n2. 起步-DevEco Studio#\n\n安装 DevEco Studio 编辑器\n\n 1. 下载：https://developer.harmonyos.com/cn/develop/deveco-studio#download\n    * Windows(64-bit)\n    * Mac(X86)\n    * Mac(ARM)\n 2. 安装：DevEco Studio → 一路 Next\n 3. 运行：\n    * 基础安装：Node.js >= 16.9.1 + Install ohpm 鸿蒙包管理器\n    * SDK 安装\n    * 安装完毕\n\n\n3. 起步-HelloWorld#\n\n创建一个空项目:\n\n 1. Create Project\n\n 2. 选择项目模板\n\n 3. 填写项目信息\n\n 4. Finish\n\n\n4. 起步-调试预览#\n\n调试预览方法：\n\n * Previewer 预览模式\n * Local Emulator 本地模拟器\n * Remote Emulator 远程模拟器\n * Remote Device 远程真机\n * Local Device 本地真机\n\n推荐使用\n * Previewer 预览 和 Local Emulator 本地模拟器；\n * 尤其推荐使用 遥遥领先 真机调试；\n\n1）Previewer 预览\n\n> 场景：静态页面（没有组件间数据通信、不涉及到网络请求）\n> \n> 条件：有 @Entry 或 @Preview 装饰器页面\n\n * 预览和审查元素\n\n * 多设备预览\n\n2）Local Emulator 本地模拟器\n\n> 场景：动态页面（几乎全场景，一些无法模拟的硬件功能）\n\n * 新建模拟器\n   \n   一路 Next ...\n\n * 启动模拟器\n\n * 运行项目看效果\n\n * 更改后每次需要（打包 → 卸载 → 安装 → 预览），有没有热更新或者刷新这种预览方式？\n   \n   调试静态页面可以，一旦有了数据变化也需要重启，体验一般~ （学习需要耐心，期待 Next 做的更好~）\n\n其他方式\n * Remote Emulator 远程模拟器\n * Remote Device 远程真机\n * Local Device 本地真机\n\n条件：需要注册华为账号, 点这 https://developer.harmonyos.com/ 然后点击登录页面，去注册吧~\n\n\n5. 起步-工程结构#\n\n> 我们在哪里写代码？\n\nState 模型\n\n了解App结构关系，等后面我们项目阶段来讲一些工程配置文件作用，现在你要知道：\n\n * entry 是一个 Module 应用包\n\n * entryability 是一个 UIAbility 包含用户界面的应用组件\n\n * pages 是页面\n\n * components 可以是组件\n\n\n组件基础#\n\n\n1. 组件-什么是ArkTS#\n\nArkTS是HarmonyOS优选的主力应用开发语言。ArkTS围绕应用开发在TypeScript（简称TS）生态基础上做了进一步扩展，继承了TS的所有特性，是\nTS的超集。\n\n扩展能力如下：\n\n 1. 基本语法\n    * 定义声明式UI、自定义组件、动态扩展UI元素；\n    * 提供ArkUI系统组件，提供组件事件、方法、属性；\n    * 共同构成 UI 开发主体\n 2. 状态管理\n    * 组件状态、组件数据共享、应用数据共享、设备共享；\n 3. 渲染控制\n    * 条件渲染、循环渲染、数据懒加载；\n\n声明式UI？\n\n问题？通过一段 HTML 标签展示出对应的页面方便，还是使用 document.createElement('tag')创建标签构建页面方便？\n\n * 显然是 HTML , 其实 HTML 本身就是声明式的，通过描述的方式去声明 UI 界面。\n * 一些前端框架也是声明式UI，如 Vue 使用的 tempalte 模板，如 React 使用的 JSX。\n * 在例如现在的 Jetpack Compose SwiftUI Flutter 等APP开发技术也是声明式。\n\n\n2. 基础-组件结构#\n\nArkTS通过装饰器 @Component 和 @Entry 装饰 struct 关键字声明的数据结构，构成一个自定义组件。 自定义组件中提供了一个 build\n函数，开发者需在该函数内以链式调用的方式进行基本的 UI 描述，UI 描述的方法请参考 UI 描述规范。\n\n1）页面组件\n\n@Entry\n@Component\nstruct Index {\n  // 工程默认显示 `Index` 页面组件\n  // build 是声明UI的位置\n  build() {\n    Text('页面组件')\n  }\n}\n\n\n2）自定义组件\n\n\n// 定义 `Footer` 组件\n@Component\nstruct Footer {\n  build() {\n    Text('自定义组件')\n  }\n}\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    // 使用 `Footer` 组件\n    Footer()\n  }\n}\n\n\n为了更好维护，自定义组件通常会新建一个文件 Footer.ets，通过模块化语法导出导入(默认|按需)使用。\n\n * File: components/Footer.ets\n\n@Component\nexport default struct Footer {\n  build() {\n    Text('自定义组件')\n  }\n}\n\n\n * File: Index.ets\n\n\n\n@Entry\n@Component\nstruct Index {\n  build() {\n    // 使用 `Footer` 组件\n    Footer()\n  }\n}\n\n\nTIP\n * @Entry @Component 是页面组件，将来需要页面跳转就需要再定义一个页面。\n * @Component 自定义组件，一个页面组件下可以有多个自定义组件。\n * build(){} 只能有一个根元素\n\n\n3. 基础-系统组件(ArkUI)#\n\n常用系统组件 Text Column Row Button TextInput 更多组件\n\n * Text 文本组件\n * Column 列组件，纵向排列，Flex布局主轴是Y\n * Row 行组件，横向向排列，Flex布局主轴是X\n * Button 按钮组件\n * InputText 输入框组件\n\n实现一个简易登录界面：\n\n@Entry\n@Component\nstruct Index {\n\n  build() {\n    Column(){\n      Row(){\n        Text('手机号')\n        TextInput()\n      }\n      Row(){\n        Text('验证码')\n        TextInput()\n      }\n      Row(){\n        Button('重置').backgroundColor('#ccc')\n        Button('登录')\n      }\n    }\n  }\n}\n\n\nTIP\n * ArkUI 组件都是 Flex 模式，由行和列组成。\n\n\n4. 基础-组件状态#\n\n> 如何使用 @State 定义一个状态变量？\n\n1）组件变量，不具备驱动UI更新能力。\n\n@Entry\n@Component\nstruct Index {\n  count = 100\n\n  build() {\n    Text(this.count.toString())\n      .onClick(() => this.count++)\n  }\n}\n\n\n2）状态变量，指驱动UI更新的数据，加上 @State 装饰器即可，注意：加上类型和初始值。\n\n@Entry\n@Component\nstruct Index {\n\n  @State\n  count: number = 100\n\n  build() {\n    Text(this.count.toString())\n      .onClick(() => this.count++)\n  }\n}\n\n\nTIP\n * 状态变量不可设置的类型有：any undefined null 与复杂类型的联合类型\n * 绑定事件在系统组件后链式使用 onXxxxx 进行绑定即可\n * 使用 @ohos.promptAction 可以使用亲提示 promptAction.showToast({ message: 'Tip' })\n\n📕📕📕 练习案例→实现登录表单数据收集、重置、模拟提交。\n\n\n@Entry\n@Component\nstruct Index {\n\n  @State\n  mobile: string = ''\n  @State\n  code: string = ''\n\n  build() {\n    Column(){\n      Row(){\n        Text('手机号')\n        TextInput({ text: this.mobile }).onChange((value)=>this.mobile = value)\n      }\n      Row(){\n        Text('验证码')\n        TextInput({ text: this.code }).onChange((value)=>this.code = value)\n      }\n      Row(){\n        Button('重置')\n          .backgroundColor('#ccc')\n          .onClick(()=>{\n            this.mobile = ''\n            this.code = ''\n          })\n        Button('登录')\n          .onClick(()=>{\n            if (this.mobile && this.code) {\n              promptAction.showToast({ message: `${this.mobile} 登录成功` })\n            } else {\n              promptAction.showToast({ message: `请输入手机号或验证码` })\n            }\n          })\n      }\n    }\n  }\n}\n\n\n\n样式处理#\n\n\n1. 样式-布局容器#\n\n\n2. 样式-语法(链式&枚举)#\n\n\n3. 样式-@Styles 复用#\n\n\n4. 样式-@Extends 复用#\n\n\n组件状态#\n\n\n1. 状态-简单状态#\n\n\n2. 状态-复杂状态#\n\n\n界面渲染#\n\n\n1. 渲染-条件渲染#\n\n\n2. 渲染-循环渲染#\n\n\n今日案例#","frontmatter":{"title":"HM - 鸿蒙-组件基础"},"version":""},{"id":2,"title":"HM - 鸿蒙-状态管理","routePath":"/interview-handbook-project/guide/state","lang":"","toc":[],"domain":"","content":"#","frontmatter":{"title":"HM - 鸿蒙-状态管理"},"version":""},{"id":4,"title":"面试宝典APP","routePath":"/interview-handbook-project/project/","lang":"","toc":[],"domain":"","content":"#","frontmatter":{},"version":""}]